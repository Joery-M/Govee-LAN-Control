{"version":3,"sources":["../src/index.ts","../src/commands/setColors.ts","../src/commands/setOnOff.ts","../src/commands/createSocket.ts"],"sourcesContent":["import { RemoteInfo, Socket, createSocket } from 'dgram';\r\nimport { fade, setBrightness, setColor, updateValues } from './commands/setColors';\r\nimport { setOff, setOn } from './commands/setOnOff';\r\nimport getSocket from './commands/createSocket';\r\nimport { EventEmitter } from 'events';\r\nimport * as ct from 'color-temperature';\r\n\r\nexport interface DeviceState {\r\n    isOn: number,\r\n    brightness: number,\r\n    color: { \"r\": number, \"g\": number, \"b\": number },\r\n    colorKelvin: number,\r\n    hasReceivedUpdates: boolean\r\n}\r\n\r\nexport class Device extends EventEmitter\r\n{\r\n    constructor(data: Record<string, any>, GoveeInstance: Govee, socket: Socket)\r\n    {\r\n        super();\r\n        deviceList.set(data.ip, this);\r\n\r\n        this.model = data.sku;\r\n        this.deviceID = data.device;\r\n        this.ip = data.ip;\r\n        this.versions = {\r\n            BLEhardware: data.bleVersionHard,\r\n            BLEsoftware: data.bleVersionSoft,\r\n            WiFiHardware: data.wifiVersionHard,\r\n            WiFiSoftware: data.wifiVersionSoft\r\n        };\r\n\r\n        this.state = {\r\n            isOn: 0,\r\n            brightness: 0,\r\n            color: { \"r\": 0, \"g\": 0, \"b\": 0 },\r\n            colorKelvin: 0,\r\n            hasReceivedUpdates: false\r\n        };\r\n\r\n        this.socket = socket;\r\n        this.updateTimer = setInterval(() =>\r\n        {\r\n            this.updateValues();\r\n        }, 6000);\r\n\r\n        // When the status gets changes, emit it on the main class aswell\r\n        this.on(\"updatedStatus\", (data, stateChanged) => {\r\n            GoveeInstance.emit(\"updatedStatus\", this, data, stateChanged)\r\n        })\r\n    }\r\n    readonly ip: string;\r\n    readonly deviceID: string;\r\n    readonly model: string;\r\n    readonly socket: Socket;\r\n    readonly versions: {\r\n        BLEhardware: string;\r\n        BLEsoftware: string;\r\n        WiFiHardware: string;\r\n        WiFiSoftware: string;\r\n    };\r\n    public state: DeviceState;\r\n    readonly actions = new actions(this);\r\n    readonly updateValues = async () => await updateValues(this);\r\n    private updateTimer: NodeJS.Timer;\r\n    public destroy = () =>\r\n    {\r\n        this.emit(\"destroyed\");\r\n        clearTimeout(this.updateTimer);\r\n    };\r\n}\r\n\r\nclass actions\r\n{\r\n    constructor(device: Device)\r\n    {\r\n        this.device = device;\r\n    }\r\n    private device: Device;\r\n    setColor = (color: colorOptions): Promise<void> => setColor.call(this.device, color);\r\n\r\n    /**\r\n     * @description\r\n     * Pass a 0-100 value to set the brightness of the device.\r\n     */\r\n    setBrightness = (brightness: string | number): Promise<void> => setBrightness.call(this.device, brightness);\r\n\r\n    /**\r\n     * @description\r\n     * #### Fade the color and brightness of your device.\r\n     * **Warning**: This works by sending many many commands (At least every 10ms).\r\n     * \r\n     * Before the code gets run for sending values, the state of the device gets updated.\r\n     * ***\r\n     * Usage:\r\n     * ```js\r\n     * fadeColor({\r\n            time: 2000, // In milliseconds\r\n            color: {\r\n                hex: \"#282c34\" // Other options possible\r\n            },\r\n            brightness: 20 // 0-100\r\n        });\r\n     * ```\r\n     */\r\n    fadeColor = (options: fadeOptions): Promise<void> => fade.call(this.device, eventEmitter, options);\r\n\r\n    /**\r\n     * @description\r\n     * Turn off a device.\r\n     */\r\n    setOff = (): Promise<void> => setOff.call(this.device);\r\n\r\n    /**\r\n     * @description\r\n     * Turn on a device.\r\n     */\r\n    setOn = (): Promise<void> => setOn.call(this.device);\r\n}\r\n\r\nclass GoveeConfig\r\n{\r\n    /**\r\n     * Automatically start searching for devices when the UDP socket is made.\r\n     * @default true\r\n     */\r\n    startDiscover?: boolean = true;\r\n    /**\r\n     * The interval (in ms) at which new devices will be scanned for.\r\n     * @default 60000 (1 minute)\r\n     */\r\n    discoverInterval?: number = 60000;\r\n}\r\n\r\n//TODO: I have no idea why i have to define the variables outside the class. But when theyre inside the class, they're always undefined outside of the constructor.\r\nvar deviceList = new Map<string, Device>();\r\nvar eventEmitter: EventEmitter;\r\nvar udpSocket: Socket;\r\n\r\nclass Govee extends EventEmitter\r\n{\r\n    private config?: GoveeConfig;\r\n    private isReady = false;\r\n    constructor(config?: GoveeConfig)\r\n    {\r\n        super();\r\n        eventEmitter = this;\r\n        this.config = config;\r\n\r\n        this.getSocket().then(() =>\r\n        {\r\n            this.emit(\"ready\");\r\n            this.isReady = true;\r\n        });\r\n\r\n        var discoverInterval = 60_000;\r\n\r\n        if (config && config.discoverInterval)\r\n        {\r\n            discoverInterval = config.discoverInterval;\r\n        }\r\n\r\n        this.once(\"ready\", () =>\r\n        {\r\n            this.discoverInterval = setInterval(() =>\r\n            {\r\n                this.discover();\r\n            }, discoverInterval);\r\n        });\r\n    }\r\n\r\n    private discoverInterval: NodeJS.Timer;\r\n\r\n    private getSocket = (): Promise<void> =>\r\n    {\r\n        return new Promise<void>((resolve, reject) =>\r\n        {\r\n            getSocket().then(async (socket) =>\r\n            {\r\n                if (!socket)\r\n                {\r\n                    console.error(\"UDP Socket was not estabilished whilst trying to discover new devices.\\n\\nIs the server able to access UDP port 4001 and 4002 on address 239.255.255.250?\");\r\n                    var whileSocket = undefined\r\n                    while (whileSocket == undefined) {\r\n                        whileSocket = await getSocket()\r\n                        if (whileSocket == undefined) {\r\n                            console.error(\"UDP Socket was not estabilished whilst trying to discover new devices.\\n\\nIs the server able to access UDP port 4001 and 4002 on address 239.255.255.250?\");\r\n                        }\r\n                    }\r\n                    udpSocket = whileSocket\r\n                }else {\r\n                    udpSocket = socket\r\n                }\r\n\r\n                udpSocket.on(\"message\", this.receiveMessage);\r\n\r\n                //? Now that we have a socket, we can scan (again)\r\n                //TODO: Creating the socket and scanning can probably combined into 1, but i don't want to risk it, seeing as i have 1 govee device\r\n                if (!this.config || this.config.startDiscover)\r\n                {\r\n                    this.discover();\r\n                }\r\n                if (!this.isReady)\r\n                {\r\n                    this.emit(\"ready\");\r\n                    this.isReady = true;\r\n                }\r\n                resolve();\r\n            });\r\n        });\r\n    };\r\n\r\n\r\n    /**\r\n     * @description\r\n     * Use this function to re-send the command to scan for devices.\r\n     * \r\n     * Note that you typically don't have to run this command yourself. \r\n     */\r\n    public discover = () =>\r\n    {\r\n        if (!udpSocket)\r\n        {\r\n            console.error(\"UDP Socket was not estabilished whilst trying to discover new devices.\\n\\nIs the server able to access UDP port 4001 and 4002 on address 239.255.255.250?\");\r\n            return;\r\n        }\r\n        let message = JSON.stringify(\r\n            {\r\n                \"msg\": {\r\n                    \"cmd\": \"scan\",\r\n                    \"data\": {\r\n                        \"account_topic\": \"reserve\",\r\n                    }\r\n                }\r\n            }\r\n        );\r\n        udpSocket.send(message, 0, message.length, 4001, \"239.255.255.250\");\r\n        deviceList.forEach((dev) =>\r\n        {\r\n            udpSocket.send(message, 0, message.length, 4003, dev.ip);\r\n            this.discoverTimes[dev.ip] ||= 0;\r\n            this.discoverTimes[dev.ip]++;\r\n\r\n            if (this.discoverTimes[dev.ip] >= 5)\r\n            {\r\n                eventEmitter.emit(\"deviceRemoved\", dev);\r\n                dev.destroy();\r\n                deviceList.delete(dev.ip);\r\n            }\r\n        });\r\n    };\r\n\r\n    private discoverTimes: Map<string, number> = new Map();\r\n\r\n    private receiveMessage = async (msg: Buffer, rinfo: RemoteInfo) =>\r\n    {\r\n        var msgRes: messageResponse = JSON.parse(msg.toString());\r\n        if (!udpSocket)\r\n        {\r\n            return;\r\n        }\r\n        var data = msgRes.msg.data;\r\n        switch (msgRes.msg.cmd)\r\n        {\r\n            case \"scan\":\r\n                var oldList = Array.from(deviceList.values());\r\n                if (!deviceList.has(data.ip))\r\n                {\r\n                    var device = new Device(data, this, udpSocket);\r\n                    device.updateValues();\r\n                }\r\n                this.discoverTimes[data.ip] = 0;\r\n                oldList.forEach((device) =>\r\n                {\r\n                    if (!deviceList.has(device.ip))\r\n                    {\r\n                        eventEmitter.emit(\"deviceRemoved\", device);\r\n                        device.destroy();\r\n                        deviceList.delete(device.ip);\r\n                    }\r\n                });\r\n                break;\r\n\r\n            case \"devStatus\":\r\n                var device = deviceList.get(rinfo.address);\r\n\r\n                var oldState = JSON.parse(JSON.stringify(device.state));\r\n                device.state.brightness = data.brightness;\r\n                device.state.isOn = data.onOff;\r\n                device.state.color = data.color;\r\n\r\n                if (!data.color.colorTemInKelvin)\r\n                {\r\n                    device.state.colorKelvin = ct.rgb2colorTemperature({ red: data.color.r, green: data.color.g, blue: data.color.b });\r\n                } else\r\n                {\r\n                    device.state.colorKelvin = data.color.colorTemInKelvin;\r\n                }\r\n\r\n                var stateChanged: stateChangedOptions = [];\r\n                var colorChanged = oldState.color.r !== data.color.r || oldState.color.g !== data.color.g || oldState.color.b !== data.color.b;\r\n                var brightnessChanged = oldState.brightness !== data.brightness;\r\n                var onOffChanged = oldState.isOn !== data.onOff;\r\n\r\n                //* This may seem like a weird way of doing things, but i want to first get the full state of the device, then i can say it has been added\r\n                if (!device.state.hasReceivedUpdates)\r\n                {\r\n                    device.state.hasReceivedUpdates = true;\r\n                    eventEmitter.emit(\"deviceAdded\", device);\r\n                }\r\n\r\n                if (brightnessChanged)\r\n                {\r\n                    stateChanged.push(\"brightness\");\r\n                }\r\n                if (colorChanged)\r\n                {\r\n                    stateChanged.push(\"color\");\r\n                }\r\n                if (onOffChanged)\r\n                {\r\n                    stateChanged.push(\"onOff\");\r\n                }\r\n                device.emit(\"updatedStatus\", device.state, stateChanged as stateChangedOptions);\r\n                // eventEmitter.emit(\"updatedStatus\", device, device.state, stateChanged);\r\n                break;\r\n\r\n            default:\r\n                break;\r\n        }\r\n    };\r\n\r\n\r\n    /**\r\n     * A map of devices where the devices' IP is the key, and the Device object is the value.\r\n     */\r\n    public get devicesMap (): Map<string, Device>\r\n    {\r\n        return deviceList;\r\n    }\r\n    /**\r\n     * An array of all devices.\r\n     */\r\n    public get devicesArray (): Device[]\r\n    {\r\n        return Array.from(deviceList.values());\r\n    }\r\n\r\n    /**\r\n     * Retrieve the values of all devices.\r\n     */\r\n    public async updateAllDevices ()\r\n    {\r\n        const updatePromises = this.devicesArray.map((device) => device.updateValues);\r\n        await Promise.all(updatePromises);\r\n        return;\r\n    }\r\n\r\n    public destroy ()\r\n    {\r\n        eventEmitter.removeAllListeners();\r\n        deviceList = new Map<string, Device>();\r\n        eventEmitter = undefined;\r\n        udpSocket.close();\r\n        udpSocket = undefined;\r\n        clearInterval(this.discoverInterval);\r\n        //? Loop over all devices and clear their timeouts\r\n        deviceList.forEach((device) =>\r\n        {\r\n            device.destroy();\r\n        });\r\n    }\r\n}\r\n\r\nexport default Govee;\r\n\r\ninterface messageResponse\r\n{\r\n    msg: {\r\n        cmd: \"devStatus\" | \"scan\",\r\n        data: Record<string, any>;\r\n    };\r\n}\r\n\r\nexport interface DataResponseStatus\r\n{\r\n    onOff: 0 | 1;\r\n    brightness: number;\r\n    color: {\r\n        r: number;\r\n        g: number;\r\n        b: number;\r\n    };\r\n    colorTemInKelvin: number;\r\n}\r\n\r\nexport type stateChangedOptions = (\"onOff\" | \"brightness\" | \"color\" | undefined)[];\r\n\r\nexport interface fadeOptions\r\n{\r\n    time: number;\r\n    color?: colorOptions;\r\n    brightness?: number;\r\n}\r\n\r\ninterface colorOptionsHex\r\n{\r\n    hex: string;\r\n    rgb?: never;\r\n    hsl?: never;\r\n    kelvin?: never;\r\n}\r\ninterface colorOptionsRGB\r\n{\r\n    hex?: never;\r\n    rgb: [number, number, number];\r\n    hsl?: never;\r\n    kelvin?: never;\r\n}\r\ninterface colorOptionsHSL\r\n{\r\n    hex?: never;\r\n    rgb?: never;\r\n    hsl: [number, number, number];\r\n    kelvin?: never;\r\n}\r\ninterface colorOptionsKelvin\r\n{\r\n    hex?: never;\r\n    rgb?: never;\r\n    hsl?: never;\r\n    kelvin: string | number;\r\n}\r\nexport type colorOptions = colorOptionsHex | colorOptionsRGB | colorOptionsHSL | colorOptionsKelvin;\r\n\r\n\r\ntype DeviceEventTypes =\r\n    {\r\n        updatedStatus: (data: DeviceState, stateChanged: stateChangedOptions) => void;\r\n        destroyed: () => void;\r\n    };\r\n\r\nexport declare interface Device\r\n{\r\n    addListener<E extends keyof DeviceEventTypes> (event: E, listener: DeviceEventTypes[E]): this;\r\n    on<E extends keyof DeviceEventTypes> (event: E, listener: DeviceEventTypes[E]): this;\r\n    once<E extends keyof DeviceEventTypes> (event: E, listener: DeviceEventTypes[E]): this;\r\n    prependListener<E extends keyof DeviceEventTypes> (event: E, listener: DeviceEventTypes[E]): this;\r\n    prependOnceListener<E extends keyof DeviceEventTypes> (event: E, listener: DeviceEventTypes[E]): this;\r\n\r\n    off<E extends keyof DeviceEventTypes> (event: E, listener: DeviceEventTypes[E]): this;\r\n    removeAllListeners<E extends keyof DeviceEventTypes> (event?: E): this;\r\n    removeListener<E extends keyof DeviceEventTypes> (event: E, listener: DeviceEventTypes[E]): this;\r\n\r\n    emit<E extends keyof DeviceEventTypes> (event: E, ...args: Parameters<DeviceEventTypes[E]>): boolean;\r\n    // The sloppy `eventNames()` return type is to mitigate type incompatibilities - see #5\r\n    eventNames (): (keyof DeviceEventTypes | string | symbol)[];\r\n    rawListeners<E extends keyof DeviceEventTypes> (event: E): DeviceEventTypes[E][];\r\n    listeners<E extends keyof DeviceEventTypes> (event: E): DeviceEventTypes[E][];\r\n    listenerCount<E extends keyof DeviceEventTypes> (event: E): number;\r\n\r\n    getMaxListeners (): number;\r\n    setMaxListeners (maxListeners: number): this;\r\n}\r\n\r\ntype GoveeEventTypes = {\r\n    ready: () => void;\r\n    deviceAdded: (device: Device) => void;\r\n    deviceRemoved: (device: Device) => void;\r\n    updatedStatus: (device: Device, data: DeviceState, stateChanged: stateChangedOptions) => void;\r\n};\r\n\r\ninterface Govee\r\n{\r\n    addListener<E extends keyof GoveeEventTypes> (event: E, listener: GoveeEventTypes[E]): this;\r\n    on<E extends keyof GoveeEventTypes> (event: E, listener: GoveeEventTypes[E]): this;\r\n    once<E extends keyof GoveeEventTypes> (event: E, listener: GoveeEventTypes[E]): this;\r\n    prependListener<E extends keyof GoveeEventTypes> (event: E, listener: GoveeEventTypes[E]): this;\r\n    prependOnceListener<E extends keyof GoveeEventTypes> (event: E, listener: GoveeEventTypes[E]): this;\r\n\r\n    off<E extends keyof GoveeEventTypes> (event: E, listener: GoveeEventTypes[E]): this;\r\n    removeAllListeners<E extends keyof GoveeEventTypes> (event?: E): this;\r\n    removeListener<E extends keyof GoveeEventTypes> (event: E, listener: GoveeEventTypes[E]): this;\r\n\r\n    emit<E extends keyof GoveeEventTypes> (event: E, ...args: Parameters<GoveeEventTypes[E]>): boolean;\r\n    // The sloppy `eventNames()` return type is to mitigate type incompatibilities - see #5\r\n    eventNames (): (keyof GoveeEventTypes | string | symbol)[];\r\n    rawListeners<E extends keyof GoveeEventTypes> (event: E): GoveeEventTypes[E][];\r\n    listeners<E extends keyof GoveeEventTypes> (event: E): GoveeEventTypes[E][];\r\n    listenerCount<E extends keyof GoveeEventTypes> (event: E): number;\r\n\r\n    getMaxListeners (): number;\r\n    setMaxListeners (maxListeners: number): this;\r\n}","import Govee, { colorOptions, DataResponseStatus, Device, fadeOptions, stateChangedOptions } from \"..\";\r\nimport { hex, hsl, rgb } from \"color-convert\";\r\nimport * as ct from 'color-temperature';\r\n\r\n/**\r\n * \r\n * @param x Starting number\r\n * @param y Ending number\r\n * @param a percent (0-1)\r\n */\r\nconst lerp = (x: number, y: number, a: number) => x * (1 - a) + y * a;\r\n/**\r\n * \r\n * @param a Starting number\r\n * @param b Ending number\r\n * @param amount percent (0-1)\r\n */\r\nfunction lerpColor (a: string, b: string, amount: number)\r\n{\r\n\r\n    var ah = parseInt(a.replace(/#/g, ''), 16),\r\n        ar = ah >> 16, ag = ah >> 8 & 0xff, ab = ah & 0xff,\r\n        bh = parseInt(b.replace(/#/g, ''), 16),\r\n        br = bh >> 16, bg = bh >> 8 & 0xff, bb = bh & 0xff,\r\n        rr = ar + amount * (br - ar),\r\n        rg = ag + amount * (bg - ag),\r\n        rb = ab + amount * (bb - ab);\r\n\r\n    return '#' + ((1 << 24) + (rr << 16) + (rg << 8) + rb | 0).toString(16).slice(1);\r\n}\r\n\r\n/**\r\n * Returns a bezier interpolated value, using the given ranges\r\n * @param {number} value  Value to be interpolated\r\n * @param {number} s1 Source range start\r\n * @param {number} s2  Source range end\r\n * @param {number} t1  Target range start\r\n * @param {number} t2  Target range end\r\n * @param {number} [slope]  Weight of the curve (0.5 = linear, 0.1 = weighted near target start, 0.9 = weighted near target end)\r\n * @returns {number} Interpolated value\r\n */\r\nvar interpolate = function (value: number, s1: number, s2: number, t1: any, t2: any, slope: number)\r\n{\r\n    //Default to linear interpolation\r\n    slope = slope || 0.5;\r\n\r\n    //If the value is out of the source range, floor to min/max target values\r\n    if (value < Math.min(s1, s2))\r\n    {\r\n        return Math.min(s1, s2) === s1 ? t1 : t2;\r\n    }\r\n\r\n    if (value > Math.max(s1, s2))\r\n    {\r\n        return Math.max(s1, s2) === s1 ? t1 : t2;\r\n    }\r\n\r\n    //Reverse the value, to make it correspond to the target range (this is a side-effect of the bezier calculation)\r\n    value = s2 - value;\r\n\r\n    var C1 = { x: s1, y: t1 }; //Start of bezier curve\r\n    var C3 = { x: s2, y: t2 }; //End of bezier curve\r\n    var C2 = {              //Control point\r\n        x: C3.x,\r\n        y: C1.y + Math.abs(slope) * (C3.y - C1.y)\r\n    };\r\n\r\n    //Find out how far the value is on the curve\r\n    var percent = value / (C3.x - C1.x);\r\n\r\n    return C1.y * b1(percent) + C2.y * b2(percent) + C3.y * b3(percent);\r\n\r\n    function b1 (t: number) { return t * t; }\r\n    function b2 (t: number) { return 2 * t * (1 - t); }\r\n    function b3 (t: number) { return (1 - t) * (1 - t); }\r\n};\r\n\r\n/**\r\n * @description\r\n * Set the color of a light.\r\n */\r\nexport function setColor (this: Device, options: colorOptions): Promise<void>\r\n{\r\n    var device = this;\r\n    return new Promise((resolve, reject) =>\r\n    {\r\n        var rgb = { r: 0, g: 0, b: 0 };\r\n        var message: string;\r\n\r\n        if (options.kelvin)\r\n        {\r\n            var kelvin = parseFloat(options.kelvin.toString().replace(/[^0-9]/g, \"\"));\r\n\r\n            message = JSON.stringify(\r\n                {\r\n                    msg: {\r\n                        cmd: \"colorwc\",\r\n                        data: {\r\n                            colorTemInKelvin: kelvin\r\n                        }\r\n                    }\r\n                }\r\n            );\r\n        } else\r\n        {\r\n            if (options.hex !== undefined)\r\n            {\r\n                var newColor = hex.rgb(options.hex);\r\n                rgb = {\r\n                    r: newColor[0],\r\n                    g: newColor[1],\r\n                    b: newColor[2]\r\n                };\r\n            } else if (options.hsl !== undefined)\r\n            {\r\n                var newColor = hsl.rgb(options.hsl);\r\n                rgb = {\r\n                    r: newColor[0],\r\n                    g: newColor[1],\r\n                    b: newColor[2]\r\n                };\r\n            } else if (options.rgb !== undefined)\r\n            {\r\n                rgb = {\r\n                    r: options.rgb[0],\r\n                    g: options.rgb[1],\r\n                    b: options.rgb[2]\r\n                };\r\n            }\r\n\r\n            message = JSON.stringify(\r\n                {\r\n                    msg: {\r\n                        cmd: \"colorwc\",\r\n                        data: {\r\n                            color: rgb\r\n                        }\r\n                    }\r\n                }\r\n            );\r\n        }\r\n\r\n        //! Commands have to be send twice te be caught by devstatus... annoying\r\n        // device.socket?.send(message, 0, message.length, 4001, device.ip, () =>\r\n        // {\r\n            device.socket?.send(message, 0, message.length, 4003, device.ip, async () =>\r\n            {\r\n                if (rgb)\r\n                {\r\n                    device.state.color = rgb;\r\n                    device.state.colorKelvin = ct.rgb2colorTemperature({ red: rgb.r, green: rgb.g, blue: rgb.b });\r\n                } else if (kelvin)\r\n                {\r\n                    var rgbColor = ct.colorTemperature2rgb(kelvin);\r\n                    device.state.color = { r: rgbColor.red, g: rgbColor.green, b: rgbColor.blue };\r\n                    device.state.colorKelvin = kelvin;\r\n                }\r\n                device.emit(\"updatedStatus\", device.state, [\"color\"])\r\n                resolve();\r\n                // await sleep(100)\r\n                // updateValues(device, false)\r\n            });\r\n        // });\r\n    });\r\n}\r\n\r\nexport function setBrightness (this: Device, brightness: number | string): Promise<void>\r\n{\r\n    return new Promise((resolve, reject) =>\r\n    {\r\n        var bright = Math.round(parseFloat(brightness.toString()) * 100) / 100;\r\n        let message = JSON.stringify(\r\n            {\r\n                \"msg\": {\r\n                    \"cmd\": \"brightness\",\r\n                    \"data\": {\r\n                        \"value\": bright,\r\n                    }\r\n                }\r\n            }\r\n        );\r\n        //! Commands have to be send twice te be caught by devstatus... annoying\r\n        // this.socket?.send(message, 0, message.length, 4001, this.ip, ()=>{\r\n            this.socket?.send(message, 0, message.length, 4003, this.ip, async () =>\r\n            {\r\n                this.state.brightness = bright;\r\n                resolve();\r\n                await sleep(100)\r\n                this.emit(\"updatedStatus\", this.state, [\"brightness\"])\r\n                // updateValues(this, false)\r\n            });\r\n        // });\r\n    });\r\n}\r\n\r\nexport function fade (this: Device, eventEmitter: Govee, options: fadeOptions): Promise<void>\r\n{\r\n    return new Promise(async (resolve, reject) =>\r\n    {\r\n        var device = this;\r\n        //? Get current value\r\n        await updateValues(device);\r\n        await sleep(100);\r\n\r\n        var curHex = rgb.hex(device.state.color.r, device.state.color.g, device.state.color.b);\r\n        var curKelvin = ct.rgb2colorTemperature({ red: device.state.color.r, green: device.state.color.g, blue: device.state.color.b });\r\n        var curBrightness = device.state.isOn == 1 ? device.state.brightness : 1;\r\n        var targetKelvin: number;\r\n        var targetBright = options.brightness;\r\n\r\n        if (options.color?.kelvin)\r\n        {\r\n            targetKelvin = parseFloat(options.color.kelvin.toString().replace(/[^0-9]/g, \"\"));\r\n        }\r\n\r\n        var changeColor = options.color?.hex !== undefined || options.color?.hsl !== undefined || options.color?.rgb !== undefined;\r\n\r\n        var startTime = Date.now();\r\n\r\n        var newColor = \"\";\r\n        if (options.color?.hsl !== undefined)\r\n            newColor = hsl.hex(options.color.hsl);\r\n        else if (options.color?.rgb !== undefined)\r\n            newColor = rgb.hex(options.color.rgb);\r\n        else if (options.color?.hex !== undefined)\r\n            newColor = options.color.hex.replace(/#/g, '');\r\n\r\n        async function stepBrightness (percent: number)\r\n        {\r\n            var newBright = lerp(curBrightness, targetBright, Math.max(Math.min(percent, 1), 0));\r\n            device.actions.setBrightness(newBright);\r\n        }\r\n\r\n        async function stepColor (percent: number, newColor: string)\r\n        {\r\n            var lerpedColor = lerpColor(curHex, newColor, Math.max(Math.min(percent, 1), 0));\r\n\r\n            device.actions.setColor({ hex: \"#\" + lerpedColor });\r\n        }\r\n\r\n        async function stepKelvin (percent: number, targetKelvin: number)\r\n        {\r\n            var lerpedKelvin = lerp(curKelvin, targetKelvin, Math.max(Math.min(percent, 1), 0));\r\n            var kelvinRGB = ct.colorTemperature2rgb(lerpedKelvin);\r\n\r\n            device.actions.setColor({ rgb: [kelvinRGB.red, kelvinRGB.green, kelvinRGB.blue] });\r\n        }\r\n\r\n        // Start loop\r\n        var running = true;\r\n        setTimeout(async () =>\r\n        {\r\n            running = false;\r\n            if (changeColor)\r\n            {\r\n                setColor.call(device, {\r\n                    hex: newColor\r\n                });\r\n            } else if (targetKelvin)\r\n            {\r\n                var kelvinRGB = ct.colorTemperature2rgb(targetKelvin);\r\n                await device.actions.setColor({ rgb: [kelvinRGB.red, kelvinRGB.green, kelvinRGB.blue] });\r\n            }\r\n            if (options.brightness !== undefined)\r\n            {\r\n                device.actions.setBrightness(targetBright);\r\n            }\r\n\r\n            await sleep(50);\r\n            await device.updateValues();\r\n            var updatedValues: stateChangedOptions = []\r\n            if (curBrightness !== targetBright) {\r\n                updatedValues.push(\"brightness\")\r\n            }\r\n            if (changeColor) {\r\n                updatedValues.push(\"color\")\r\n            }\r\n            device.emit(\"updatedStatus\", device.state, updatedValues)\r\n            resolve();\r\n        }, options.time - 100);\r\n        while (running == true)\r\n        {\r\n            var startLoopTime = Date.now();\r\n            var percent = interpolate((Date.now() - startTime) / (options.time - 100), 0, 1, 0, 1, 0.5);\r\n            // Color step\r\n            if (changeColor)\r\n            {\r\n                stepColor(percent, newColor);\r\n            }\r\n\r\n            // Kelvin step\r\n            if (options.color && options.color.kelvin !== undefined)\r\n            {\r\n                stepKelvin(percent, targetKelvin);\r\n            }\r\n\r\n            // Brightness step\r\n            if (options.brightness !== undefined)\r\n            {\r\n                stepBrightness(percent);\r\n            }\r\n            await sleep(30 - (Date.now() - startLoopTime));\r\n        }\r\n    });\r\n}\r\n\r\nfunction sleep (ms: number): Promise<void>\r\n{\r\n    return new Promise((resolve, reject) =>\r\n    {\r\n        setTimeout(() =>\r\n        {\r\n            resolve();\r\n        }, ms);\r\n    });\r\n}\r\n\r\nexport function updateValues (device?: Device, updateAll?: boolean)\r\n{\r\n    return new Promise<void>((resolve, reject) =>\r\n    {\r\n        let message = JSON.stringify(\r\n            {\r\n                \"msg\": {\r\n                    \"cmd\": \"devStatus\",\r\n                    \"data\": {}\r\n                }\r\n            }\r\n        );\r\n        if (!updateAll)\r\n        {\r\n            device.socket.send(message, 0, message.length, 4003, device.ip);\r\n            resolve();\r\n        } else\r\n        {\r\n            device.socket.send(message, 0, message.length, 4001, \"239.255.255.250\");\r\n            resolve();\r\n        }\r\n    });\r\n}","import { Device } from \"..\";\r\n\r\nexport function setOff (this: Device): Promise<void>\r\n{\r\n    var device = this;\r\n    return new Promise((resolve, reject) =>\r\n    {\r\n        let message = JSON.stringify(\r\n            {\r\n                msg: {\r\n                    cmd: \"turn\",\r\n                    data: {\r\n                        value: 0\r\n                    }\r\n                }\r\n            }\r\n        );\r\n        device.socket?.send(message, 0, message.length, 4003, device.ip, async () =>\r\n        {\r\n            device.state.isOn = 0;\r\n            device.emit(\"updatedStatus\", device.state, [\"onOff\"])\r\n            resolve();\r\n        });\r\n    });\r\n}\r\n\r\n/**\r\n * @description\r\n * Turn on a light.\r\n */\r\nexport function setOn (this: Device): Promise<void>\r\n{\r\n    var device = this;\r\n    return new Promise((resolve, reject) =>\r\n    {\r\n        let message = JSON.stringify(\r\n            {\r\n                msg: {\r\n                    cmd: \"turn\",\r\n                    data: {\r\n                        value: 1\r\n                    }\r\n                }\r\n            }\r\n        );\r\n        device.socket?.send(message, 0, message.length, 4003, device.ip, () =>\r\n        {\r\n            device.state.isOn = 1;\r\n            device.emit(\"updatedStatus\", device.state, [\"onOff\"])\r\n            resolve();\r\n        });\r\n    });\r\n}","import { createSocket, Socket } from 'node:dgram';\r\nimport { networkInterfaces } from 'os';\r\nconst address = '239.255.255.250';\r\nconst port = 4002;\r\n\r\n\r\n//? Loop over all network interfaces (that apply) to find one with Govee devices.\r\nexport default (): Promise<Socket> =>\r\n{\r\n    return new Promise((resolve, reject) =>\r\n    {\r\n        const nets = networkInterfaces();\r\n        var sockets: Socket[] = []\r\n        var isResolved = false\r\n\r\n        //* Modified from https://stackoverflow.com/a/8440736/11186759\r\n        for (const name of Object.keys(nets))\r\n        {\r\n            nets[name]?.forEach((net) =>\r\n            {\r\n                const familyV4Value = typeof net.family === 'string' ? 'IPv4' : 4;\r\n                if (net.family === familyV4Value && !net.internal)\r\n                {\r\n                    let socket = createSocket({\r\n                        type: 'udp4',\r\n                        reuseAddr: true // for testing multiple instances on localhost\r\n                    });\r\n                    sockets.push(socket)\r\n\r\n                    socket.once('message', (msg, remote) =>\r\n                    {\r\n                        resolve(socket);\r\n                        isResolved = true\r\n                    });\r\n\r\n\r\n                    socket.bind(port, net.address);\r\n\r\n                    socket.on(\"listening\", function ()\r\n                    {\r\n                        socket.setBroadcast(true);\r\n                        socket.setMulticastTTL(128);\r\n                        socket.addMembership(address);\r\n                        let message = JSON.stringify(\r\n                            {\r\n                                \"msg\": {\r\n                                    \"cmd\": \"scan\",\r\n                                    \"data\": {\r\n                                        \"account_topic\": \"reserve\",\r\n                                    }\r\n                                }\r\n                            }\r\n                        );\r\n                        socket.send(message, 0, message.length, 4001, address);\r\n                    });\r\n                }\r\n            });\r\n        }\r\n\r\n        setTimeout(() => {\r\n            if (isResolved == false) {\r\n                sockets.forEach((socket)=>{\r\n                    socket.close()\r\n                })\r\n                resolve(undefined)\r\n            }\r\n        }, 5000);\r\n    });\r\n};"],"mappings":"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","names":["rgb","eventEmitter","percent","newColor","targetKelvin","ct","data","device"]}