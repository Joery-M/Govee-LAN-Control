{"version":3,"sources":["../src/commands/setColors.ts","../src/commands/setOnOff.ts","../src/commands/createSocket.ts","../src/index.ts"],"sourcesContent":["import Govee, { colorOptions, DataResponseStatus, Device, fadeOptions, udpSocket } from \"..\";\r\nimport { hex, hsl, rgb } from \"color-convert\";\r\nimport * as ct from 'color-temperature';\r\n\r\n/**\r\n * \r\n * @param x Starting number\r\n * @param y Ending number\r\n * @param a percent (0-1)\r\n */\r\nconst lerp = (x: number, y: number, a: number) => x * (1 - a) + y * a;\r\n/**\r\n * \r\n * @param a Starting number\r\n * @param b Ending number\r\n * @param amount percent (0-1)\r\n */\r\nfunction lerpColor (a: string, b: string, amount: number)\r\n{\r\n\r\n    var ah = parseInt(a.replace(/#/g, ''), 16),\r\n        ar = ah >> 16, ag = ah >> 8 & 0xff, ab = ah & 0xff,\r\n        bh = parseInt(b.replace(/#/g, ''), 16),\r\n        br = bh >> 16, bg = bh >> 8 & 0xff, bb = bh & 0xff,\r\n        rr = ar + amount * (br - ar),\r\n        rg = ag + amount * (bg - ag),\r\n        rb = ab + amount * (bb - ab);\r\n\r\n    return '#' + ((1 << 24) + (rr << 16) + (rg << 8) + rb | 0).toString(16).slice(1);\r\n}\r\n\r\n/**\r\n * Returns a bezier interpolated value, using the given ranges\r\n * @param {number} value  Value to be interpolated\r\n * @param {number} s1 Source range start\r\n * @param {number} s2  Source range end\r\n * @param {number} t1  Target range start\r\n * @param {number} t2  Target range end\r\n * @param {number} [slope]  Weight of the curve (0.5 = linear, 0.1 = weighted near target start, 0.9 = weighted near target end)\r\n * @returns {number} Interpolated value\r\n */\r\nvar interpolate = function (value: number, s1: number, s2: number, t1: any, t2: any, slope: number)\r\n{\r\n    //Default to linear interpolation\r\n    slope = slope || 0.5;\r\n\r\n    //If the value is out of the source range, floor to min/max target values\r\n    if (value < Math.min(s1, s2))\r\n    {\r\n        return Math.min(s1, s2) === s1 ? t1 : t2;\r\n    }\r\n\r\n    if (value > Math.max(s1, s2))\r\n    {\r\n        return Math.max(s1, s2) === s1 ? t1 : t2;\r\n    }\r\n\r\n    //Reverse the value, to make it correspond to the target range (this is a side-effect of the bezier calculation)\r\n    value = s2 - value;\r\n\r\n    var C1 = { x: s1, y: t1 }; //Start of bezier curve\r\n    var C3 = { x: s2, y: t2 }; //End of bezier curve\r\n    var C2 = {              //Control point\r\n        x: C3.x,\r\n        y: C1.y + Math.abs(slope) * (C3.y - C1.y)\r\n    };\r\n\r\n    //Find out how far the value is on the curve\r\n    var percent = value / (C3.x - C1.x);\r\n\r\n    return C1.y * b1(percent) + C2.y * b2(percent) + C3.y * b3(percent);\r\n\r\n    function b1 (t: number) { return t * t; }\r\n    function b2 (t: number) { return 2 * t * (1 - t); }\r\n    function b3 (t: number) { return (1 - t) * (1 - t); }\r\n};\r\n\r\n/**\r\n * @description\r\n * Set the color of a light.\r\n */\r\nexport function setColor (this: Device, options: colorOptions): Promise<void>\r\n{\r\n    var device = this;\r\n    return new Promise((resolve, reject) =>\r\n    {\r\n        var rgb = { r: 0, g: 0, b: 0 };\r\n        var message: string;\r\n\r\n        if (options.kelvin)\r\n        {\r\n            var kelvin = parseFloat(options.kelvin.toString().replace(/[^0-9]/g, \"\"));\r\n\r\n            message = JSON.stringify(\r\n                {\r\n                    msg: {\r\n                        cmd: \"colorwc\",\r\n                        data: {\r\n                            colorTemInKelvin: kelvin\r\n                        }\r\n                    }\r\n                }\r\n            );\r\n        } else\r\n        {\r\n            if (options.hex !== undefined)\r\n            {\r\n                var newColor = hex.rgb(options.hex);\r\n                rgb = {\r\n                    r: newColor[0],\r\n                    g: newColor[1],\r\n                    b: newColor[2]\r\n                };\r\n            } else if (options.hsl !== undefined)\r\n            {\r\n                var newColor = hsl.rgb(options.hsl);\r\n                rgb = {\r\n                    r: newColor[0],\r\n                    g: newColor[1],\r\n                    b: newColor[2]\r\n                };\r\n            } else if (options.rgb !== undefined)\r\n            {\r\n                rgb = {\r\n                    r: options.rgb[0],\r\n                    g: options.rgb[1],\r\n                    b: options.rgb[2]\r\n                };\r\n            }\r\n\r\n            message = JSON.stringify(\r\n                {\r\n                    msg: {\r\n                        cmd: \"colorwc\",\r\n                        data: {\r\n                            color: rgb\r\n                        }\r\n                    }\r\n                }\r\n            );\r\n        }\r\n\r\n        //! Commands have to be send twice te be caught by devstatus... annoying\r\n        // device.socket?.send(message, 0, message.length, 4001, device.ip, () =>\r\n        // {\r\n            device.socket?.send(message, 0, message.length, 4001, device.ip, () =>\r\n            {\r\n                if (rgb)\r\n                {\r\n                    device.state.color = rgb;\r\n                    device.state.colorKelvin = ct.rgb2colorTemperature({ red: rgb.r, green: rgb.g, blue: rgb.b });\r\n                } else if (kelvin)\r\n                {\r\n                    var rgbColor = ct.colorTemperature2rgb(kelvin);\r\n                    device.state.color = { r: rgbColor.red, g: rgbColor.green, b: rgbColor.blue };\r\n                    device.state.colorKelvin = kelvin;\r\n                }\r\n                resolve();\r\n            });\r\n        // });\r\n    });\r\n}\r\n\r\nexport function setBrightness (this: Device, brightness: number | string): Promise<void>\r\n{\r\n    return new Promise((resolve, reject) =>\r\n    {\r\n        var bright = Math.round(parseFloat(brightness.toString()) * 100) / 100;\r\n        let message = JSON.stringify(\r\n            {\r\n                \"msg\": {\r\n                    \"cmd\": \"brightness\",\r\n                    \"data\": {\r\n                        \"value\": bright,\r\n                    }\r\n                }\r\n            }\r\n        );\r\n        //! Commands have to be send twice te be caught by devstatus... annoying\r\n        // this.socket?.send(message, 0, message.length, 4001, this.ip, ()=>{\r\n            this.socket?.send(message, 0, message.length, 4001, this.ip, () =>\r\n            {\r\n                this.state.brightness = bright;\r\n                resolve();\r\n            });\r\n        // });\r\n    });\r\n}\r\n\r\nexport function fade (this: Device, eventEmitter: Govee, options: fadeOptions): Promise<void>\r\n{\r\n    return new Promise(async (resolve, reject) =>\r\n    {\r\n        var device = this;\r\n        //? Get current value\r\n        await updateValues(device);\r\n        await sleep(100);\r\n\r\n        var curHex = rgb.hex(device.state.color.r, device.state.color.g, device.state.color.b);\r\n        var curKelvin = ct.rgb2colorTemperature({ red: device.state.color.r, green: device.state.color.g, blue: device.state.color.b });\r\n        var curBrightness = device.state.isOn == 1 ? device.state.brightness : 1;\r\n        var targetKelvin: number;\r\n        var targetBright = options.brightness;\r\n\r\n        if (options.color?.kelvin)\r\n        {\r\n            targetKelvin = parseFloat(options.color.kelvin.toString().replace(/[^0-9]/g, \"\"));\r\n        }\r\n\r\n        var changeColor = options.color?.hex !== undefined || options.color?.hsl !== undefined || options.color?.rgb !== undefined;\r\n\r\n        var startTime = Date.now();\r\n\r\n        var newColor = \"\";\r\n        if (options.color?.hsl !== undefined)\r\n            newColor = hsl.hex(options.color.hsl);\r\n        else if (options.color?.rgb !== undefined)\r\n            newColor = rgb.hex(options.color.rgb);\r\n        else if (options.color?.hex !== undefined)\r\n            newColor = options.color.hex.replace(/#/g, '');\r\n\r\n        async function stepBrightness (percent: number)\r\n        {\r\n            var newBright = lerp(curBrightness, targetBright, Math.max(Math.min(percent, 1), 0));\r\n            device.actions.setBrightness(newBright);\r\n        }\r\n\r\n        async function stepColor (percent: number, newColor: string)\r\n        {\r\n            var lerpedColor = lerpColor(curHex, newColor, Math.max(Math.min(percent, 1), 0));\r\n\r\n            device.actions.setColor({ hex: \"#\" + lerpedColor });\r\n        }\r\n\r\n        async function stepKelvin (percent: number, targetKelvin: number)\r\n        {\r\n            var lerpedKelvin = lerp(curKelvin, targetKelvin, Math.max(Math.min(percent, 1), 0));\r\n            var kelvinRGB = ct.colorTemperature2rgb(lerpedKelvin);\r\n\r\n            device.actions.setColor({ rgb: [kelvinRGB.red, kelvinRGB.green, kelvinRGB.blue] });\r\n        }\r\n\r\n        // Start loop\r\n        var running = true;\r\n        setTimeout(async () =>\r\n        {\r\n            running = false;\r\n            if (changeColor)\r\n            {\r\n                setColor.call(device, {\r\n                    hex: newColor\r\n                });\r\n            } else if (targetKelvin)\r\n            {\r\n                var kelvinRGB = ct.colorTemperature2rgb(targetKelvin);\r\n                await device.actions.setColor({ rgb: [kelvinRGB.red, kelvinRGB.green, kelvinRGB.blue] });\r\n            }\r\n            if (options.brightness !== undefined)\r\n            {\r\n                device.actions.setBrightness(targetBright);\r\n            }\r\n\r\n            await sleep(50);\r\n            await device.updateValues();\r\n            resolve();\r\n        }, options.time - 100);\r\n        while (running == true)\r\n        {\r\n            var startLoopTime = Date.now();\r\n            var percent = interpolate((Date.now() - startTime) / (options.time - 100), 0, 1, 0, 1, 0.5);\r\n            // Color step\r\n            if (changeColor)\r\n            {\r\n                stepColor(percent, newColor);\r\n            }\r\n\r\n            // Kelvin step\r\n            if (options.color.kelvin !== undefined)\r\n            {\r\n                stepKelvin(percent, targetKelvin);\r\n            }\r\n\r\n            // Brightness step\r\n            if (options.brightness !== undefined)\r\n            {\r\n                stepBrightness(percent);\r\n            }\r\n            await sleep(30 - (Date.now() - startLoopTime));\r\n        }\r\n    });\r\n}\r\n\r\nfunction sleep (ms: number): Promise<void>\r\n{\r\n    return new Promise((resolve, reject) =>\r\n    {\r\n        setTimeout(() =>\r\n        {\r\n            resolve();\r\n        }, ms);\r\n    });\r\n}\r\n\r\nexport function updateValues (device?: Device, updateAll?: boolean)\r\n{\r\n    return new Promise<void>((resolve, reject) =>\r\n    {\r\n        let message = JSON.stringify(\r\n            {\r\n                \"msg\": {\r\n                    \"cmd\": \"devStatus\",\r\n                    \"data\": {}\r\n                }\r\n            }\r\n        );\r\n        if (!updateAll)\r\n        {\r\n            udpSocket.send(message, 0, message.length, 4001, device.ip);\r\n            resolve();\r\n        } else\r\n        {\r\n            udpSocket.send(message, 0, message.length, 4001, \"239.255.255.250\");\r\n            resolve();\r\n        }\r\n    });\r\n}","import { Device } from \"..\";\r\n\r\nexport function setOff (this: Device): Promise<void>\r\n{\r\n    var device = this;\r\n    return new Promise((resolve, reject) =>\r\n    {\r\n        let message = JSON.stringify(\r\n            {\r\n                msg: {\r\n                    cmd: \"turn\",\r\n                    data: {\r\n                        value: 0\r\n                    }\r\n                }\r\n            }\r\n        );\r\n        device.socket?.send(message, 0, message.length, 4001, device.ip, () =>\r\n        {\r\n            device.updateValues();\r\n            device.state.isOn = 0;\r\n            resolve();\r\n        });\r\n    });\r\n}\r\n\r\n/**\r\n * @description\r\n * Turn on a light.\r\n */\r\nexport function setOn (this: Device): Promise<void>\r\n{\r\n    var device = this;\r\n    return new Promise((resolve, reject) =>\r\n    {\r\n        let message = JSON.stringify(\r\n            {\r\n                msg: {\r\n                    cmd: \"turn\",\r\n                    data: {\r\n                        value: 1\r\n                    }\r\n                }\r\n            }\r\n        );\r\n        device.socket?.send(message, 0, message.length, 4001, device.ip, () =>\r\n        {\r\n            device.updateValues();\r\n            device.state.isOn = 1;\r\n            resolve();\r\n        });\r\n    });\r\n}","import { createSocket, Socket } from 'node:dgram';\r\nimport { networkInterfaces } from 'os';\r\nconst address = '239.255.255.250';\r\nconst port = 4002;\r\n\r\n\r\n//? Loop over all network interfaces (that apply) to find one with Govee devices.\r\nexport default (): Promise<Socket> =>\r\n{\r\n    return new Promise((resolve, _reject) =>\r\n    {\r\n        const nets = networkInterfaces();\r\n        \r\n        //* Modified from https://stackoverflow.com/a/8440736/11186759\r\n        for (const name of Object.keys(nets))\r\n        {\r\n            nets[name]?.forEach((net) =>\r\n            {\r\n                const familyV4Value = typeof net.family === 'string' ? 'IPv4' : 4;\r\n                if (net.family === familyV4Value && !net.internal)\r\n                {\r\n                    let socket = createSocket({\r\n                        type: 'udp4',\r\n                        reuseAddr: true // for testing multiple instances on localhost\r\n                    });\r\n                    socket.on('message', (msg, remote) =>\r\n                    {\r\n                        resolve(socket)\r\n                    });\r\n\r\n\r\n                    socket.bind(port, net.address);\r\n\r\n                    socket.on(\"listening\", function ()\r\n                    {\r\n                        socket.setBroadcast(true);\r\n                        socket.setMulticastTTL(128);\r\n                        socket.addMembership(address);\r\n                        let message = JSON.stringify(\r\n                            {\r\n                                \"msg\": {\r\n                                    \"cmd\": \"scan\",\r\n                                    \"data\": {\r\n                                        \"account_topic\": \"reserve\",\r\n                                    }\r\n                                }\r\n                            }\r\n                        );\r\n                        socket.send(message, 0, message.length, 4001, address);\r\n                    });\r\n                }\r\n            });\r\n        }\r\n    });\r\n};","import { RemoteInfo, Socket } from 'dgram';\r\nimport { fade, setBrightness, setColor, updateValues } from './commands/setColors';\r\nimport { setOff, setOn } from './commands/setOnOff';\r\nimport getSocket from './commands/createSocket';\r\nimport { EventEmitter } from 'events';\r\nimport * as ct from 'color-temperature';\r\n\r\ninterface DeviceEventTypes\r\n{\r\n    updatedStatus: [data: DataResponseStatus, stateChanged: stateChangedOptions];\r\n    destroyed: [];\r\n}\r\n\r\nexport declare interface Device\r\n{\r\n    on<K extends keyof DeviceEventTypes> (\r\n        event: K,\r\n        listener: (...args: DeviceEventTypes[K]) => any,\r\n    ): this;\r\n\r\n    once<K extends keyof DeviceEventTypes> (\r\n        event: K,\r\n        listener: (...args: DeviceEventTypes[K]) => any,\r\n    ): this;\r\n}\r\n\r\nexport class Device extends EventEmitter\r\n{\r\n    constructor(data: Record<string, any>, GoveeInstance: Govee, socket: Socket)\r\n    {\r\n        super();\r\n        deviceList.set(data.ip, this);\r\n\r\n        this.model = data.sku;\r\n        this.deviceID = data.device;\r\n        this.ip = data.ip;\r\n        this.versions = {\r\n            BLEhardware: data.bleVersionHard,\r\n            BLEsoftware: data.bleVersionSoft,\r\n            WiFiHardware: data.wifiVersionHard,\r\n            WiFiSoftware: data.wifiVersionSoft\r\n        };\r\n\r\n        this.state = {\r\n            isOn: 0,\r\n            brightness: 0,\r\n            color: { \"r\": 0, \"g\": 0, \"b\": 0 },\r\n            colorKelvin: 0,\r\n            hasReceivedUpdates: false\r\n        };\r\n\r\n        this.socket = socket;\r\n        this.updateTimer = setInterval(() =>\r\n        {\r\n            this.updateValues();\r\n        }, 60000);\r\n    }\r\n    readonly ip: string;\r\n    readonly deviceID: string;\r\n    readonly model: string;\r\n    readonly socket: Socket;\r\n    readonly versions: {\r\n        BLEhardware: string;\r\n        BLEsoftware: string;\r\n        WiFiHardware: string;\r\n        WiFiSoftware: string;\r\n    };\r\n    public state!: {\r\n        isOn: number;\r\n        brightness: number;\r\n        color: Record<string, number>;\r\n        colorKelvin: number;\r\n        hasReceivedUpdates: boolean;\r\n    };\r\n    readonly actions = new actions(this);\r\n    readonly updateValues: Function = () => updateValues(this);\r\n    private updateTimer: NodeJS.Timer;\r\n    public destroy = () =>\r\n    {\r\n        this.emit(\"destroyed\");\r\n        clearTimeout(this.updateTimer);\r\n    };\r\n}\r\n\r\nclass actions\r\n{\r\n    constructor(device: Device)\r\n    {\r\n        this.device = device;\r\n    }\r\n    private device: Device;\r\n    setColor = (color: colorOptions): Promise<void> => setColor.call(this.device, color);\r\n\r\n    /**\r\n     * @description\r\n     * Pass a 0-100 value to set the brightness of the device.\r\n     */\r\n    setBrightness = (brightness: string | number): Promise<void> => setBrightness.call(this.device, brightness);\r\n\r\n    /**\r\n     * @description\r\n     * #### Fade the color and brightness of your device.\r\n     * **Warning**: This works by sending many many commands (At least every 10ms).\r\n     * \r\n     * Before the code gets run for sending values, the state of the device gets updated.\r\n     * ***\r\n     * Usage:\r\n     * ```js\r\n     * fadeColor({\r\n            time: 2000, // In milliseconds\r\n            color: {\r\n                hex: \"#282c34\" // Other options possible\r\n            },\r\n            brightness: 20 // 0-100\r\n        });\r\n     * ```\r\n     */\r\n    fadeColor = (options: fadeOptions): Promise<void> => fade.call(this.device, eventEmitter, options);\r\n\r\n    /**\r\n     * @description\r\n     * Turn off a device.\r\n     */\r\n    setOff = (): Promise<void> => setOff.call(this.device);\r\n\r\n    /**\r\n     * @description\r\n     * Turn on a device.\r\n     */\r\n    setOn = (): Promise<void> => setOn.call(this.device);\r\n}\r\n\r\ninterface GoveeEventTypes\r\n{\r\n    ready: [];\r\n    deviceAdded: [device: Device];\r\n    deviceRemoved: [device: Device];\r\n    updatedStatus: [device: Device, data: DataResponseStatus, stateChanged: stateChangedOptions];\r\n}\r\ndeclare interface Govee\r\n{\r\n    on<K extends keyof GoveeEventTypes> (\r\n        event: K,\r\n        listener: (...args: GoveeEventTypes[K]) => any,\r\n    ): this;\r\n\r\n    once<K extends keyof GoveeEventTypes> (\r\n        event: K,\r\n        listener: (...args: GoveeEventTypes[K]) => any,\r\n    ): this;\r\n}\r\n\r\n//TODO: I have no idea why i have to define the variables outside the class. I'm only able to access the socket when using \"this\"\r\nvar deviceList = new Map<string, Device>();\r\nvar eventEmitter: EventEmitter;\r\nexport var udpSocket: Socket;\r\n\r\nclass Govee extends EventEmitter\r\n{\r\n    constructor(startDiscover: boolean = true)\r\n    {\r\n        super();\r\n        eventEmitter = this;\r\n\r\n        getSocket().then((socket) =>\r\n        {\r\n            udpSocket = socket;\r\n\r\n            udpSocket.on(\"message\", this.receiveMessage);\r\n\r\n            //? Now that we have a socket, we can scan (again)\r\n            //TODO: This can probably combined into 1, but i don't want to risk it, seeing as i have 1 govee device\r\n            if (startDiscover)\r\n            {\r\n                this.discover();\r\n            }\r\n        });\r\n\r\n        this.discoverInterval = setInterval(() =>\r\n        {\r\n            this.discover();\r\n        }, 300000);\r\n    }\r\n\r\n    private discoverInterval: NodeJS.Timer;\r\n\r\n\r\n    async discover ()\r\n    {\r\n        let message = JSON.stringify(\r\n            {\r\n                \"msg\": {\r\n                    \"cmd\": \"scan\",\r\n                    \"data\": {\r\n                        \"account_topic\": \"reserve\",\r\n                    }\r\n                }\r\n            }\r\n        );\r\n        udpSocket.send(message, 0, message.length, 4001, \"239.255.255.250\");\r\n    }\r\n\r\n    private async receiveMessage (msg: Buffer, rinfo: RemoteInfo)\r\n    {\r\n        var msgRes: messageResponse = JSON.parse(msg.toString());\r\n        var data = msgRes.msg.data;\r\n        switch (msgRes.msg.cmd)\r\n        {\r\n            case \"scan\":\r\n                var oldList = deviceList;\r\n                if (!deviceList.has(data.ip))\r\n                {\r\n                    var device = new Device(data, this, udpSocket);\r\n                    device.updateValues();\r\n                }\r\n                oldList.forEach((device) =>\r\n                {\r\n                    if (!deviceList.has(device.ip))\r\n                    {\r\n                        eventEmitter.emit(\"deviceRemoved\", device);\r\n                        device.destroy();\r\n                        deviceList.delete(device.ip);\r\n                    }\r\n                });\r\n                break;\r\n\r\n            case \"devStatus\":\r\n                var device = deviceList.get(rinfo.address);\r\n\r\n                var oldState = JSON.parse(JSON.stringify(device.state));\r\n                device.state.brightness = data.brightness;\r\n                device.state.isOn = data.onOff;\r\n                device.state.color = data.color;\r\n\r\n                if (!data.color.colorTemInKelvin)\r\n                {\r\n                    device.state.colorKelvin = ct.rgb2colorTemperature({ red: data.color.r, green: data.color.g, blue: data.color.b });\r\n                } else\r\n                {\r\n                    device.state.colorKelvin = data.color.colorTemInKelvin;\r\n                }\r\n\r\n                var stateChanged: string[] = [];\r\n                var colorChanged = oldState.color.r !== data.color.r || oldState.color.g !== data.color.g || oldState.color.b !== data.color.b;\r\n                var brightnessChanged = oldState.brightness !== data.brightness;\r\n                var onOffChanged = oldState.isOn !== data.onOff;\r\n\r\n                //* This may seem like a weird way of doing things, but i want to first get the full state of the device, then i can say it has been added\r\n                if (!device.state.hasReceivedUpdates)\r\n                {\r\n                    device.state.hasReceivedUpdates = true;\r\n                    eventEmitter.emit(\"deviceAdded\", device);\r\n                }\r\n\r\n                if (brightnessChanged)\r\n                {\r\n                    stateChanged.push(\"brightness\");\r\n                }\r\n                if (colorChanged)\r\n                {\r\n                    stateChanged.push(\"color\");\r\n                }\r\n                if (onOffChanged)\r\n                {\r\n                    stateChanged.push(\"onOff\");\r\n                }\r\n                device.emit(\"updatedStatus\", data, stateChanged);\r\n                eventEmitter.emit(\"updatedStatus\", device, data, stateChanged);\r\n                break;\r\n\r\n            default:\r\n                break;\r\n        }\r\n    }\r\n\r\n\r\n    public get devicesMap (): Map<string, Device>\r\n    {\r\n        return deviceList;\r\n    }\r\n    public get devicesArray (): Device[]\r\n    {\r\n        return Array.from(deviceList.values());\r\n    }\r\n\r\n    public updateAllDevices ()\r\n    {\r\n        updateValues(this.devicesArray[0], true);\r\n    }\r\n\r\n    public destroy ()\r\n    {\r\n        //? Loop over all devices and clear their timeouts\r\n        deviceList.forEach((device) =>\r\n        {\r\n            device.destroy();\r\n        });\r\n        eventEmitter.removeAllListeners();\r\n        deviceList = new Map<string, Device>();\r\n        eventEmitter = undefined;\r\n        udpSocket = undefined;\r\n        clearInterval(this.discoverInterval)\r\n    }\r\n}\r\n\r\nexport default Govee;\r\n\r\ninterface messageResponse\r\n{\r\n    msg: {\r\n        cmd: \"devStatus\" | \"scan\",\r\n        data: Record<string, any>;\r\n    };\r\n}\r\n\r\nexport interface DataResponseStatus\r\n{\r\n    onOff: 0 | 1;\r\n    brightness: number;\r\n    color: {\r\n        r: number;\r\n        g: number;\r\n        b: number;\r\n    };\r\n    colorTemInKelvin: number;\r\n}\r\n\r\nexport type stateChangedOptions = (\"onOff\" | \"brightness\" | \"color\" | undefined)[];\r\n\r\nexport interface fadeOptions\r\n{\r\n    time: number;\r\n    color?: colorOptions;\r\n    brightness?: number;\r\n}\r\n\r\ninterface colorOptionsHex\r\n{\r\n    hex: string;\r\n    rgb?: never;\r\n    hsl?: never;\r\n    kelvin?: never;\r\n}\r\ninterface colorOptionsRGB\r\n{\r\n    hex?: never;\r\n    rgb: [number, number, number];\r\n    hsl?: never;\r\n    kelvin?: never;\r\n}\r\ninterface colorOptionsHSL\r\n{\r\n    hex?: never;\r\n    rgb?: never;\r\n    hsl: [number, number, number];\r\n    kelvin?: never;\r\n}\r\ninterface colorOptionsKelvin\r\n{\r\n    hex?: never;\r\n    rgb?: never;\r\n    hsl?: never;\r\n    kelvin: string | number;\r\n}\r\nexport type colorOptions = colorOptionsHex | colorOptionsRGB | colorOptionsHSL | colorOptionsKelvin;"],"mappings":"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","names":["rgb","eventEmitter","percent","newColor","targetKelvin","ct","Device","Govee","device"]}